## ğŸŒŸÂ **Introduction to Transactions**

- **Definition**: A sequence of operations performed as a single logical unit of work.
    - **Atomicity**: Either all operations complete or none do.
    - **Consistency**: Transitions preserve system rules (constraints, cascades).
    - **Isolation**: Concurrent transactions donâ€™t interfere (as if executed sequentially).
    - **Durability**: Committed changes persist even after crashes.

ğŸ”¹Â **Origins**:

- Databases â†’ Transactional file servers (1980s) â†’ Distributed objects (1990s) â†’ Middleware (e.g., CORBA).
    

---

## ğŸŒÂ **Distributed Transactions**

- **Why?**Â Real-world systems span multiple databases/services (e.g., banking, e-commerce).
    
- **Example**:
    
    - DebitÂ 100fromBankAâ†’Credit100fromBankAâ†’Credit100 to Bank B.
        
    - Inventory â†’ Billing â†’ Shipment in e-commerce.
        

---

## ğŸ’½Â **Recoverable Objects & Failure Model**

- **Recoverable Objects**: Stored in permanent storage; survive server crashes.
    
- **Failure Model**:
    
    - **Disks/Servers**: Writes may fail; reads detect errors via checksums.
        
    - **Communication**: Messages may be lost/delayed/corrupted.
        

---

## ğŸ”„Â **Transaction Lifecycle**

|**Successful**|**Aborted by Client**|**Aborted by Server**|
|---|---|---|
|`openTransaction`|`openTransaction`|`openTransaction`|
|Operations|Operations|Operations|
|`closeTransaction`|`abortTransaction`|Operation ERROR|

---
## âš ï¸Â **Concurrency Problems**
### ğŸ”„Â **1. Lost Update Problem**

**What Happens?**  
Two transactions read the same data, modify it independently, and one overwrites the otherâ€™s change.

**Example**:

- **Bank Transfer**:
    
    - **Initial Balance**: AccountÂ `B`Â = $200.
        
    - **Transaction T**: ReadsÂ 200â†’Adds10200â†’Adds1020) â†’ New balance = $220.
        
    - **Transaction U**:Â _Simultaneously_Â readsÂ 200â†’Adds10200â†’Adds1020) â†’ New balance = $220.
        
    - **Expected**:Â 200â†’200â†’220 â†’ $242 (two 10% increases).
        
    - **Actual**: Final balance isÂ 220(âˆ—âˆ—220(âˆ—âˆ—22 profit lost!**).
        

**Why?**Â Both transactions used theÂ **old value**Â ($200) to calculate the new balance.

---

### ğŸ“‰Â **2. Inconsistent Retrievals (Dirty Read)**

**What Happens?**  
A transaction reads intermediate (uncommitted) data from another transaction, leading to incorrect results.

**Example**:

- **E-Commerce Order**:
    
    - **Transaction V**: Transfers $100 fromÂ `A`Â (Wallet) â†’Â `B`Â (Vendor).
        
        - Step 1:Â `A.withdraw(100)`Â â†’Â `A`Â = $0 (uncommitted).
            
        - Step 2:Â `B.deposit(100)`Â â†’Â `B`Â = $300 (pending).
            
    - **Transaction W**: Calculates total fundsÂ _during_Â the transfer:
        
        - ReadsÂ `A`Â =Â 0(afterwithdraw)+â€˜Bâ€˜=0(afterwithdraw)+â€˜Bâ€˜=200 (_before_Â deposit) â†’Â **Total = $200**.
            
    - **Expected Total**: $300 (ifÂ `V`Â completes).
        
    - **Actual**:Â 200(âˆ—âˆ—200(âˆ—âˆ—100 "vanishes"**).
        

**Why?**Â `W`Â saw a partial (inconsistent) state of the transfer.

---

### ğŸ§ŸÂ **3. Dirty Read (Uncommitted Dependency)**

**What Happens?**  
A transaction reads data modified by another transactionÂ **that later aborts**, leaving invalid data.

**Example**:

- **Flight Booking**:
    
    - **Transaction T**: Books Seat 7A â†’ SetsÂ `Seat7A = "Occupied"`Â (uncommitted).
        
    - **Transaction U**: ReadsÂ `Seat7A = "Occupied"`Â â†’ Assigns Seat 7B instead.
        
    - **Then**:Â `T`Â aborts (e.g., payment fails) â†’Â `Seat7A`Â reverts to "Empty".
        
    - **Result**: Seat 7A is empty, but userÂ `U`Â got 7B unnecessarily.
        

**Why?**Â `U`Â relied on uncommitted (dirty) data.

---

### â³Â **4. Non-Repeatable Read**

**What Happens?**  
A transaction reads the same data twice, but the value changes between reads due to another transactionâ€™s update.

**Example**:

- **Inventory Check**:
    
    - **Transaction T**: Checks stock of "Laptop":
        
        - Read 1: 10 units available.
            
        - **Transaction U**: Sells 3 laptops â†’ Updates stock to 7.
            
        - Read 2: Now 7 units.
            
    - **Confusion**: Did 3 laptops vanish? Or was the first read wrong?
        

**Why?**Â No isolation betweenÂ `T`Â andÂ `U`.

---

### ğŸ‘»Â **5. Phantom Read**

**What Happens?**  
A transaction queries a set of rows, but another transactionÂ **adds/deletes**Â rows, making the result "phantomly" change.

**Example**:

- **Hotel Reservations**:
    
    - **Transaction T**: Searches for "Available rooms with ocean view" â†’ Finds 5.
        
    - **Transaction U**:Â _Adds_Â a new ocean-view room (Room 6).
        
    - **Transaction T**: Repeats search â†’ Now finds 6 rooms.
        
    - **Question**: Did a room magically appear?
        

**Why?**Â New rows appear mid-transaction.

---

### ğŸ› ï¸Â **How to Fix These?**

|**Problem**|**Solution**|**Tool**|
|---|---|---|
|Lost Update|Locking (`SELECT FOR UPDATE`)|ğŸ”’Â **Pessimistic Locking**|
|Inconsistent Retrievals|Read committed data only|â±ï¸Â **Timestamp Ordering**|
|Dirty Read|Delay reads until writes commit|ğŸ“œÂ **Strict 2PL**|
|Non-Repeatable Read|Snapshot isolation|ğŸ“¸Â **MVCC (Multi-Versioning)**|
|Phantom Read|Range locks or predicate locking|ğŸ”Â **Serializable Isolation**|

---

### ğŸŒŸÂ **Key Insight**

These problems occur because transactionsÂ **overlap unpredictably**. Solutions enforce:

1. **Isolation**: Like a "Do Not Disturb" sign for data.
    
2. **Serializability**: As if transactions ran one after another.
    

ğŸ’¡Â **Remember**: The more concurrency you allow, the tighter your control must be!
        

---

## ğŸ”’Â **Concurrency Control Solutions**

### ğŸ“ŒÂ **Serial Equivalence**

- Schedule transactions to appear as if executed sequentially.
- **Rules**:
    - Conflicting operations (read-write, write-write) must execute in the same order across all objects.

### ğŸ”Â **Two-Phase Locking (Strict)**
1. **Growing Phase**: Acquire locks (read/write).
2. **Shrinking Phase**: Release locks only after commit/abort.

- **Lock Types**:
    - **Read (Shared)**: Multiple transactions can read.
    - **Write (Exclusive)**: Only one transaction can write.

|**Lock Requested**|**None**|**Read**|**Write**|
|---|---|---|---|
|**Read**|âœ…|âœ…|âŒ (Wait)|
|**Write**|âœ…|âŒ (Wait)|âŒ (Wait)|

### â³Â **Timestamp Ordering**

- Assign timestamps to transactions; validate operations based on:
    - **Write Rule**:Â `T_c â‰¥ max(read timestamp) && T_c > write timestamp`.
    - **Read Rule**:Â `T_c > write timestamp`Â (wait or abort if late).

### ğŸŒˆÂ **Optimistic Concurrency Control**

- **Phases**:
    
    1. **Working**: Execute freely.
        
    2. **Validation**: Check conflicts at commit (abort if needed).
        
    3. **Update**: Make changes permanent.
        
- **Types**:
    
    - **Backward Validation**: Compare read set with past transactionsâ€™ write sets.
        
    - **Forward Validation**: Compare write set with active transactionsâ€™ read sets.
        

---

## â˜ ï¸Â **Deadlocks**

- **Detection**: Wait-for graphs (cycles = deadlock).
    
    - _Solution_: Abort a victim transaction (e.g., oldest or most involved).
        
- **Prevention**:
    
    - Lock ordering (predictable but reduces concurrency).
        
    - Timeouts (but may abort non-deadlocked transactions).
        

---

## ğŸ”„Â **Nested Transactions**

- **Structure**: Parent â†’ Sub-transactions (can commit/abort independently).
- **Rules**:
    - Sub-transaction failure â†’ Retry or rollback (parent may still commit).
    - Parent abort â†’ All sub-transactions rollback

---

## ğŸ“ŠÂ **Comparison of Methods**

|**Method**|**Approach**|**Pros**|**Cons**|
|---|---|---|---|
|**Locking**|Pessimistic|Dynamic order; handles writes well|Deadlocks; overhead|
|**Timestamp Ordering**|Pessimistic|No deadlocks; good for reads|Aborts due to late operations|
|**Optimistic**|Optimistic|Low overhead (few conflicts)|Starvation; aborts repeat work|

---

## ğŸ¯Â **Summary**

- **Serializability**: Achieved via conflict resolution (locking, timestamps, validation).
    
- **Recovery**: Strict executions avoid cascading aborts.
    
- **Trade-offs**:
    
    - Locking â†’ Deadlocks.
        
    - Timestamp â†’ Aborts.
        
    - Optimistic â†’ Starvation.
        

---

âœ¨Â **Key Emojis**:

- âš¡Â **Atomicity**Â | ğŸ”„Â **Isolation**Â | ğŸ“¦Â **Durability**Â | ğŸ§©Â **Consistency**
    
- ğŸ”Â **Read**Â | âœï¸Â **Write**Â | â±ï¸Â **Timestamp**Â | ğŸ’€Â **Deadlock**



[[Q & A]]

[[08. Security]]

[[Distributed Guide]]