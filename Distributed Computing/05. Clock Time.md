# **â° Time and Clocks in Distributed Systems**

## **ğŸŒ 1. Introduction**

**ğŸ”¹ Why measure time accurately?**

- Track event timestamps on computers.
    
- Sync with authoritative external clocks (e.g.,Â **UTC**).
    

**ğŸ”¹ Use cases:**

- Concurrency control (**timestamp ordering**).
    
- Authenticity (e.g.,Â **Kerberos**).
    

**ğŸ”¹ Challenges:**

- **No global clock**Â in distributed systems.
    
- **Logical time**Â ğŸ•°ï¸ provides event ordering for consistency in replicated data.
    

---

## **ğŸ–¥ï¸ 2. Computer Clocks & Timing Events**

- Each computer has anÂ **internal clock**Â for local processes.
    
- **Issues:**
    
    - â±ï¸ Clocks on different computersÂ **may differ**.
        
    - **Clock drift rate**Â ğŸŒ€: Difference from a perfect clock.
        
    - Quartz clocks driftÂ **~1 sec/11-12 days**Â (10â»â¶ sec/sec).
        

**ğŸ“Œ Key terms:**

- **Skew**Â â†”ï¸: Instantaneous difference between two clocks.
    
- **Drift rate**Â ğŸ“‰: Time deviation per unit.
    

---

## **ğŸ“œ 3. Clocks, Events & Process States**

- **Distributed System (DS)**Â = Collection ofÂ **processes**Â communicating viaÂ **messages**.
    
- **Process actions:**
    
    - ğŸ“¤Â **Send**
        
    - ğŸ“¥Â **Receive**
        
    - ğŸ”„Â **Change state**
        
- **Event**Â âš¡: Single action (e.g., Send, Receive).
    
- **History**Â ğŸ“–: Ordered sequence of events at a process.
    

---

## **ğŸ”„ 4. Clock Synchronization**

### **ğŸŒ External Sync**

- Sync withÂ **UTC**Â (authoritative source).
    
- **Bound:**Â `|S(t) - C(t)| < D`Â over time intervalÂ `I`.
    

### **ğŸ¤ Internal Sync**

- Clocks agree within boundÂ `D`:Â `|Câ‚(t) - Câ‚‚(t)| < D`.
    
- Internally synced clocks mayÂ **still drift collectively**.
    

### **âš¡ Synchronous Systems**

- Bounded process execution time.
    
- Bounded message transmission time.
    
- Bounded clock drift rate.
    

---

## **ğŸ”§ 5. Clock Correction Methods**

### **â³ Cristianâ€™s Method (1989)**

1. Process requests time from serverÂ **S**.
    
2. Sets clock toÂ `received time + T_round/2`.  
    âœ…Â **Accuracy:**Â `Â±(T_round/2 - min)`.
    

### **ğŸ“Š Berkeley Algorithm**

1. **Master**Â pollsÂ **slaves**Â for clock values.
    
2. Estimates usingÂ **round-trip times**.
    
3. Averages & sends adjustments.  
    âœ…Â **Handles faulty clocks!**
    

### **ğŸŒ Network Time Protocol (NTP)**

- **Hierarchy:**
    
    - ğŸ†Â **Primary servers**Â (UTC-connected).
        
    - ğŸ¥ˆÂ **Secondary servers**Â sync to primary.
        
- **Accuracy:**
    
    - **10s of ms**Â (Internet).
        
    - **1 ms**Â (LANs).
        
- **Message Exchange:**
    
    - Timestamps forÂ **Send/Receive**Â events.
        
    - EstimatesÂ **offset (o)**Â andÂ **delay (d)**.
        

---

## **ğŸ§  6. Logical Time & Clocks**

### **ğŸ”¢ Lamportâ€™s Logical Clocks (1978)**

- **Rules:**  
    1ï¸âƒ£ Events at same process are ordered.  
    2ï¸âƒ£Â `Send(m) â†’ Receive(m)`.  
    3ï¸âƒ£ Transitive ordering.
    
- **Implementation:**
    
    - Monotonic counter (**Láµ¢**).
        
    - **LC1:**Â IncrementÂ `Láµ¢`Â before each event.
        
    - **LC2:**Â On send, piggybackÂ `Láµ¢`; on receipt, setÂ `Lâ±¼ = max(Lâ±¼, t) + 1`.
        

### **ğŸ“Š Vector Clocks**

- **Structure:**Â Array ofÂ `N`Â integers (**Váµ¢**).
    
- **Rules:**  
    1ï¸âƒ£ InitializeÂ `V[i] = 0`.  
    2ï¸âƒ£ IncrementÂ `V[i]`Â before timestamping.  
    3ï¸âƒ£ PiggybackÂ `Váµ¢`Â on messages.  
    4ï¸âƒ£ On receipt, updateÂ `V[j] = max(V[j], t[j])`.
    

---

## **ğŸ›°ï¸ 7. Coordinated Universal Time (UTC)**

- Based onÂ **atomic clocks**Â (drift rate:Â **10â»Â¹Â³**).
    
- Broadcast via:
    
    - ğŸ“»Â **Radio**Â (0.1â€“10 ms accuracy).
        
    - ğŸ›°ï¸Â **GPS**Â (~1 Âµs accuracy).
        

---

## **ğŸ“ 8. Key Formulas**

### **ğŸ”„ Clock Correction**

$$
S = c(E - T_{\text{skew}}) + T_{\text{skew}}
$$

- `T_skew`Â = Errant clock before adjustment.
    
- `E`Â = Adjusted value.
    
- `c`Â = Rate correction factor.
    

### **â±ï¸ NTP Offset & Delay**

$$
d_i = T_{i-2} - T_{i-3} + T_i - T_{i-1}
$$

$$
o_i = \frac{(T_{i-2} - T_{i-3} + T_{i-1} - T_i)}{2}
$$

$$

$$
---


[[06. Replication]]
[[Q & A]]
[[Distributed Guide]]